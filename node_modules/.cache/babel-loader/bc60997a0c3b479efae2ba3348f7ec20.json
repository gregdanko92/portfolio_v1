{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = require(\"../validators/is.js\");\nvar _validate = require(\"../validators/validate.js\");\nconst VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nconst ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nconst FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nconst NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nconst BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nconst DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nconst NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType(...typeName);\n}\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nfunction assertNodeType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    let current = node;\n    while (node) {\n      const {\n        type\n      } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n  return validate;\n}\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n  return validate;\n}\nconst validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nconst validFieldKeys = [\"default\", \"optional\", \"deprecated\", \"validate\"];\nconst store = {};\nfunction defineAliasedType(...aliases) {\n  return (type, opts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate\n        };\n      }\n    }\n  }\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  store[type] = opts;\n}","map":{"version":3,"sources":["../../src/definitions/utils.ts"],"names":["VISITOR_KEYS","exports","ALIAS_KEYS","FLIPPED_ALIAS_KEYS","NODE_FIELDS","BUILDER_KEYS","DEPRECATED_KEYS","NODE_PARENT_VALIDATIONS","getType","val","Array","isArray","validate","typeIs","typeName","assertNodeType","validateType","validateOptional","optional","validateOptionalType","arrayOf","elementType","chain","assertValueType","assertEach","arrayOfType","validateArrayOfType","callback","validator","node","key","i","length","subkey","v","process","env","BABEL_TYPES_8_BREAKING","each","assertOneOf","values","indexOf","TypeError","JSON","stringify","oneOf","types","type","oneOfNodeTypes","assertNodeOrValueType","oneOfNodeOrValueTypes","valid","assertShape","shape","errors","property","Object","keys","error","push","message","join","shapeOf","assertOptionalChainStart","current","callee","object","fns","args","fn","chainOf","Error","validTypeOpts","validFieldKeys","store","defineAliasedType","aliases","opts","defined","inherits","slice","additional","filter","a","includes","unshift","defineType","fields","getOwnPropertyNames","field","def","default","deprecated","visitor","builder","k","deprecatedAlias","concat","undefined","forEach","alias"],"mappings":"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","sourcesContent":["import is from \"../validators/is.ts\";\nimport { validateField, validateChild } from \"../validators/validate.ts\";\nimport type * as t from \"../index.ts\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = {\n  [x: string]: FieldOptions;\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: Array<string>;\n  aliases?: Array<string>;\n  builder?: Array<string>;\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n};\n\nexport type Validator = (\n  | { type: PrimitiveTypes }\n  | { each: Validator }\n  | { chainOf: Validator[] }\n  | { oneOf: any[] }\n  | { oneOfNodeTypes: NodeTypes[] }\n  | { oneOfNodeOrValueTypes: (NodeTypes | PrimitiveTypes)[] }\n  | { shapeOf: { [x: string]: FieldOptions } }\n  | {}\n) &\n  ((node: t.Node, key: string, val: any) => void);\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [];\n  optional?: boolean;\n  deprecated?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function typeIs(typeName: NodeTypes | NodeTypes[]) {\n  return typeof typeName === \"string\"\n    ? assertNodeType(typeName)\n    : assertNodeType(...typeName);\n}\n\nexport function validateType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(typeIs(typeName));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateOptionalType(\n  typeName: NodeTypes | NodeTypes[],\n): FieldOptions {\n  return { validate: typeIs(typeName), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return arrayOf(typeIs(typeName));\n}\n\nexport function validateArrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(arrayOfType(typeName));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: Array<any>): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (getType(val) === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} expected type of ${type} but got ${getType(val)}`,\n      );\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: { [x: string]: FieldOptions }): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Array<Validator>): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = [\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n];\nconst validFieldKeys = [\"default\", \"optional\", \"deprecated\", \"validate\"];\n\nconst store = {} as Record<string, DefineTypeOpts>;\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  const visitor: Array<string> = opts.visitor || inherits.visitor || [];\n  const aliases: Array<string> = opts.aliases || inherits.aliases || [];\n  const builder: Array<string> =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n"]},"metadata":{},"sourceType":"script"}