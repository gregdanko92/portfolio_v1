{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\nvar _index = require(\"../../validators/generated/index.js\");\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n    if ((0, _index.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n    if ((0, _index.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _index.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}","map":{"version":3,"sources":["../../../src/modifications/flow/removeTypeDuplicates.ts"],"names":["getQualifiedName","node","name","id","qualification","removeTypeDuplicates","nodesIn","nodes","Array","from","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","set","type","has","push","add","existing","get","typeParameters","params","baseType","genericName"],"mappings":"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","sourcesContent":["import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: ReadonlyArray<t.FlowType | false | null | undefined>,\n): t.FlowType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n"]},"metadata":{},"sourceType":"script"}