{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\nvar _is = require(\"../validators/is.js\");\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier.js\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _helperStringParser = require(\"@babel/helper-string-parser\");\nvar _index = require(\"../constants/index.js\");\nvar _utils = require(\"./utils.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = () => ({\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    }\n  }),\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"number\"), Object.assign(function (node, key, val) {\n        if (1 / val < 0 || !Number.isFinite(val)) {\n          const error = new Error(\"NumericLiterals must be non-negative finite numbers. \" + `You can use t.valueToNode(${val}) instead.`);\n          {}\n        }\n      }, {\n        type: \"number\"\n      }))\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    }\n  }),\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\", \"using\", \"await using\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\", \"LVal\")))\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    attributes: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    attributes: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    attributes: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    module: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n          case \"new\":\n            property = \"target\";\n            break;\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n  }\n});\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let unterminatedCalled = false;\n        const error = () => {\n          throw new Error(\"Internal @babel/types error.\");\n        };\n        const {\n          str,\n          firstInvalidLoc\n        } = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n          unterminated() {\n            unterminatedCalled = true;\n          },\n          strictNumericEscape: error,\n          invalidEscapeSequence: error,\n          numericSeparatorInEscapeSequence: error,\n          unexpectedNumericSeparator: error,\n          invalidDigit: error,\n          invalidCodePoint: error\n        });\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = firstInvalidLoc ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      default: \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});","map":{"version":3,"sources":["../../src/definitions/core.ts"],"names":["defineType","fields","elements","validate","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","right","builder","BINARY_OPERATORS","expression","inOp","Object","assign","oneOfNodeTypes","value","directives","body","label","optional","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","functionCommon","params","generator","async","exports","functionTypeAnnotationCommon","returnType","functionDeclarationCommon","declare","id","predicate","parent","inherits","patternLikeCommon","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","deprecatedAlias","Number","isFinite","error","Error","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","attributes","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","module","importKind","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","raw","cooked","templateElementCookedValidator","unterminatedCalled","str","firstInvalidLoc","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","readonly","variance"],"mappings":"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","sourcesContent":["import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  type Validator,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n        ),\n      ),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertValueType(\"string\");\n        }\n\n        const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n        const pattern = assertOneOf(\"=\");\n\n        return function (node: t.AssignmentExpression, key, val) {\n          const validator = is(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      })(),\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"LVal\")\n        : assertNodeType(\n            \"Identifier\",\n            \"MemberExpression\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Directive\")),\n      ),\n      default: [],\n    },\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            \"SpreadElement\",\n            \"JSXNamespacedName\",\n            \"ArgumentPlaceholder\",\n          ),\n        ),\n      ),\n    },\n    ...(!process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertOneOf(true, false),\n            optional: true,\n          },\n        }\n      : {}),\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? Object.assign(() => {}, {\n            each: { oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"] },\n          })\n        : assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"VariableDeclaration\", \"LVal\")\n        : assertNodeType(\n            \"VariableDeclaration\",\n            \"Identifier\",\n            \"MemberExpression\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Identifier\", \"Pattern\", \"RestElement\")),\n    ),\n  },\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\")\n      : assertNodeType(\n          \"TypeParameterDeclaration\",\n          \"TSTypeParameterDeclaration\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate: (function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Decorator\")),\n    ),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (!isValidIdentifier(val, false)) {\n              throw new TypeError(`\"${val}\" is not a valid identifier name`);\n            }\n          } as Validator,\n          { type: \"string\" },\n        ),\n      ),\n    },\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n\n    const [, parentKey] = match;\n    const nonComp = { computed: false };\n\n    // We can't check if `parent.property === node`, because nodes are validated\n    // before replacing them in the AST.\n    if (parentKey === \"property\") {\n      if (is(\"MemberExpression\", parent, nonComp)) return;\n      if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if (is(\"Property\", parent, nonComp)) return;\n      if (is(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if (is(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n    } else if (parentKey === \"meta\") {\n      if (is(\"MetaProperty\", parent, { meta: node })) return;\n    }\n\n    if (\n      // Ideally we should call isStrictReservedWord if this node is a descendant\n      // of a block in strict mode. Also, we should pass the inModule option so\n      // we can disable \"await\" in module.\n      (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n      // Even if \"this\" is a keyword, we are using the Identifier\n      // node to represent it.\n      node.name !== \"this\"\n    ) {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  },\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n              if (process.env.BABEL_8_BREAKING) {\n                // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n                // numbers here.\n                if (!IS_STANDALONE) {\n                  if (!new Error().stack.includes(\"regenerator\")) {\n                    throw error;\n                  }\n                }\n              } else {\n                // TODO: Enable this warning once regenerator is fixed.\n                // https://github.com/facebook/regenerator/pull/680\n                // console.warn(error);\n              }\n            }\n          } satisfies Validator,\n          { type: \"number\" },\n        ),\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            const invalid = /[^gimsuy]/.exec(val);\n            if (invalid) {\n              throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n            }\n          } as Validator,\n          { type: \"string\" },\n        ),\n      ),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\n    \"object\",\n    \"property\",\n    \"computed\",\n    ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : []),\n  ],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    ...(!process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertOneOf(true, false),\n            optional: true,\n          },\n        }\n      : {}),\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: assertValueType(\"string\"),\n    },\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Directive\")),\n      ),\n      default: [],\n    },\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\"),\n        ),\n      ),\n    },\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      ...(!process.env.BABEL_TYPES_8_BREAKING ? { default: \"method\" } : {}),\n    },\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (node: t.ObjectMethod, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\n    \"key\",\n    \"value\",\n    \"computed\",\n    \"shorthand\",\n    ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : []),\n  ],\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"DecimalLiteral\",\n          \"PrivateName\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: [\n              \"Expression\",\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"DecimalLiteral\",\n              \"PrivateName\",\n            ],\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (val && node.computed) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n              );\n            }\n          } as Validator,\n          { type: \"boolean\" },\n        ),\n        function (node: t.ObjectProperty, key, val) {\n          if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n          if (val && !is(\"Identifier\", node.key)) {\n            throw new TypeError(\n              \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n            );\n          }\n        } as Validator,\n      ),\n      default: false,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: (function () {\n    const pattern = assertNodeType(\n      \"Identifier\",\n      \"Pattern\",\n      \"TSAsExpression\",\n      \"TSSatisfiesExpression\",\n      \"TSNonNullExpression\",\n      \"TSTypeAssertion\",\n    );\n    const expression = assertNodeType(\"Expression\");\n\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      const validator = is(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"LVal\")\n        : assertNodeType(\n            \"Identifier\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"MemberExpression\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n  },\n  validate(parent: t.ArrayPattern | t.ObjectPattern, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n    const [, listKey, index] = match as unknown as [\n      string,\n      keyof typeof parent,\n      string,\n    ];\n    if ((parent[listKey] as t.Node[]).length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  },\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Expression\")),\n      ),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"SwitchCase\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: chain(\n        assertNodeType(\"BlockStatement\"),\n        Object.assign(\n          function (node: t.TryStatement) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (!node.handler && !node.finalizer) {\n              throw new TypeError(\n                \"TryStatement expects either a handler or finalizer, or both\",\n              );\n            }\n          } as Validator,\n          {\n            oneOfNodeTypes: [\"BlockStatement\"],\n          },\n        ),\n      ),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"Expression\")\n        : assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"VariableDeclarator\")),\n      ),\n    },\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    if (!is(\"ForXStatement\", parent, { left: node })) return;\n    if (node.declarations.length !== 1) {\n      throw new TypeError(\n        `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n      );\n    }\n  },\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertNodeType(\"LVal\");\n        }\n\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n        );\n        const without = assertNodeType(\"Identifier\");\n\n        return function (node: t.VariableDeclarator, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      })(),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\", \"LVal\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"ClassMethod\",\n            \"ClassPrivateMethod\",\n            \"ClassProperty\",\n            \"ClassPrivateProperty\",\n            \"ClassAccessorProperty\",\n            \"TSDeclareMethod\",\n            \"TSIndexSignature\",\n            \"StaticBlock\",\n          ),\n        ),\n      ),\n    },\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"id\",\n    \"body\",\n    \"superClass\",\n    \"mixins\",\n    \"typeParameters\",\n    \"superTypeParameters\",\n    \"implements\",\n    \"decorators\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n        ),\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n        ),\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    attributes: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    // TODO(Babel 8): Deprecated\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      validate: assertNodeType(\n        \"TSDeclareFunction\",\n        \"FunctionDeclaration\",\n        \"ClassDeclaration\",\n        \"Expression\",\n      ),\n    },\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: chain(\n        assertNodeType(\"Declaration\"),\n        Object.assign(\n          function (node: t.ExportNamedDeclaration, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.specifiers.length) {\n              throw new TypeError(\n                \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n              );\n            }\n          } as Validator,\n          { oneOfNodeTypes: [\"Declaration\"] },\n        ),\n        function (node: t.ExportNamedDeclaration, key, val) {\n          if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n          // This validator isn't put at the top level because we can run it\n          // even if this node doesn't have a parent.\n\n          if (val && node.source) {\n            throw new TypeError(\"Cannot export a declaration from a source\");\n          }\n        },\n      ),\n    },\n    attributes: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    // TODO(Babel 8): Deprecated\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    specifiers: {\n      default: [],\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          (function () {\n            const sourced = assertNodeType(\n              \"ExportSpecifier\",\n              \"ExportDefaultSpecifier\",\n              \"ExportNamespaceSpecifier\",\n            );\n            const sourceless = assertNodeType(\"ExportSpecifier\");\n\n            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n\n            return function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } as Validator;\n          })(),\n        ),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertNodeType(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return function (node, key, val) {\n          if (is(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    attributes: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    // TODO(Babel 8): Deprecated\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    specifiers: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"ImportSpecifier\",\n            \"ImportDefaultSpecifier\",\n            \"ImportNamespaceSpecifier\",\n          ),\n        ),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: chain(\n        assertNodeType(\"Identifier\"),\n        Object.assign(\n          function (node: t.MetaProperty, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            let property;\n            switch (val.name) {\n              case \"function\":\n                property = \"sent\";\n                break;\n              case \"new\":\n                property = \"target\";\n                break;\n              case \"import\":\n                property = \"meta\";\n                break;\n            }\n            if (!is(\"Identifier\", node.property, { name: property })) {\n              throw new TypeError(\"Unrecognised MetaProperty\");\n            }\n          } as Validator,\n          { oneOfNodeTypes: [\"Identifier\"] },\n        ),\n      ),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (node: any, key: string, val: any) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(\n        assertNodeType(\n          \"Identifier\",\n          \"Pattern\",\n          \"RestElement\",\n          \"TSParameterProperty\",\n        ),\n      ),\n    ),\n  },\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Decorator\")),\n    ),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"properties\",\n    \"typeAnnotation\",\n    \"decorators\" /* for legacy param decorators */,\n  ],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"RestElement\", \"ObjectProperty\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n  process.env.BABEL_8_BREAKING\n    ? undefined\n    : {\n        aliases: [\"Expression\"],\n      },\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TemplateElement\")),\n      ),\n    },\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } as Validator,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.YieldExpression, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (val && !node.argument) {\n              throw new TypeError(\n                \"Property delegate of YieldExpression cannot be true if there is no argument\",\n              );\n            }\n          } as Validator,\n          { type: \"boolean\" },\n        ),\n      ),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertValueType(\"boolean\")\n        : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            \"SpreadElement\",\n            \"JSXNamespacedName\",\n            \"ArgumentPlaceholder\",\n          ),\n        ),\n      ),\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertValueType(\"boolean\")\n        : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (node: any, key: string, val: any) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          };\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n"]},"metadata":{},"sourceType":"script"}